#include <iostream>
/**
 * 编译器对 inline 函数的处理步骤
 * 将inline函数体复制到inline函数调用点处
 * 为所用inline函数中的局部变量分配内存空间
 * 将inline函数的输入参数和返回值映射到调用方法的局部变量空间中
 * 如果inline函数有多个返回点，将其转换成inline函数代码块末尾的分支（使用 goto）
 *
 */
 /**
  * 内联能提高函数的效率，但不是所有的函数都定义为内联函数；内联是以代码膨胀为代价
  * 仅仅省去了函数调用的开销，从而提高函数的执行效率
  * 如果执行函数体内代码的时间相比于函数调用的开销较大，那么效率的收获会更少
  * 另一个方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间
  *
  *
  */

#include "Test.h"
int main()
{
    // 此处的虚函数 who（），是通过类（base）的具体对象b来调用的，编译期间就能确定了，
    // 所以它可以内联的，但是最终解释归编译器
    Base b;
    b.who();

    // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行期间才能确定，所以不能内联
    Base *ptr = new Derived();
    ptr -> who();
    //

    // 因为有虚构函数 先调用派生 derived的析构函数，再调用base的析构函数，防止内存泄漏

    delete ptr;
    ptr = nullptr;



    std::cout << "Hello, World!" << std::endl;
    return 0;
}

//虚函数 virtual 可以是内联函数 inline
//虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态的时候不能内联
//内联实在编译期建议编译器内敛的，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个
//函数，因此虚函数表现为多态性的时候不可以内联
// inline virtual唯一可以内联的时候是：编译器知道所有的对象是哪个类，这只有在编译器具有实际对象而不是对象的指针或引用时才会发生


